
## Потоковые манипуляторы

#include <iomanip>
setw - задать ширину поля ввода
setprecision - точность вывода вещественных чисел
setfill - заполнитель для setw
left - выравнивание данных по левому краю
fixed - выведение чисел в фиксированном формате

## Ввод и вывод пользовательских типов
// оператор вывода в поток
ostream& operator<<(ostream &s, Obj &o)
// оператор ввода из потока
istream& operator>>(istream &s, Obj &o)

## Удобное использование пользовательских типов
??? operator ???(???)
bool operator <(const &Tobj lhs, const &Tobj rhs)
Tobj operator +(const &Tobj lhs, const &Tobj rhs)

## Удобный способ сообщить о проблеме: exception, runtime_error, ...
try
{
    // опасный код
}
catch (const exception &e)
{
    // обработка ошибки
    // e.what() возвращает текст ошибки
}

## Кортежи:
- Упрощают реализацию operator<
- Позволяют вернуть несколько значений из функции и сохранить их
Пары - частный случай кортежей, но чуть приятнее

## structure bindings
tuple<bool, string> FindCountry()
{
    return {false, "Not exist"};
}

auto [success, message] = FindCountry();

## Вставка в произвольное место вектора
v.insert(it, value) вставляет value перед итератором it:
v.insert(v.end(), value) вставит value перед end

v.insert(it, range_begin, range_end)
вставляет диапазон [range_begin, range_end] в позицию it
v.insert(it, count, value)
count раз вставляет элемент value в позицию it
v.insert(it, {1, 2, 3})
вставляет 1, 2, 3 в позицию it

## Обратные итераторы
Упрощают итерирование по контейнеру в обратную сторону
sort(rbegin(v), rend(v)) - сортировка вектора по убыванию

## Справочник по C++ - https://ru.cppreference.com/w/
## Алгоритмы C++ - https://ru.cppreference.com/w/cpp/algorithm

## Категории итераторов
Input: итераторы любых контейнеров
Forward, Bidir: итераторы любых контейнеров (кроме set и map, если нужно менять содержимое)
Random: итераторы векторов и строк
Output: итераторы векторов и строк, inserter, back_inserter
Полный список требований к input-итераторам: https://en.cppreference.com/w/cpp/named_req/InputIterator
Полный список требований к output-итераторам: https://en.cppreference.com/w/cpp/named_req/OutputIterator
Полный список требований к forward-итераторам: https://en.cppreference.com/w/cpp/named_req/ForwardIterator
Полный список требований к bidirectional-итераторам: https://en.cppreference.com/w/cpp/named_req/BidirectionalIterator
Полный список требований к итераторам произвольного доступа: https://en.cppreference.com/w/cpp/named_req/RandomAccessIterator
Полный список требований к contiguous-итераторам: https://en.cppreference.com/w/cpp/named_req/ContiguousIterator
next замещает it + 1 или it + n;
prev замещает it - 1 или it - n;
advance замещает it += n;
distance замещает it2 - it1.
vector<bool> устроен так, что каждый элемент занимает в нём не один байт (как одна переменная типа bool), а один бит

## Дек - очередь
#include <deque>
d.push_back(x), d.pop_back()
d.push_front(x) - добавление в начало
d.pop_front(x) - удаление из начала
d[i] - обращение по индексу
Дек умеет больше, чем вектор, поэтому менее эффективен.
Если нужно только записывать и удалять из конца, то использовать вектор

## Очередь
#include <queue>
Умеет совсем немного:
q.push(q), q.pop() - добавляет в конец и удаляет из начала
q.front(), q.back()
q.size(), q.empty()
по данному контейнеру нельзя проитерироваться

## Стэк
#include <stack>
Позволяет лишь добавлять в конец и удалять из конца
Как вектор, но умеет меньше:
st.push(x), st.pop()
st.top()
st.size(), st.empty()

Если нужен вектор с добавлением в начало или удалением из начала, используйте deque
Нужна лишь очередь - используйте queue
Нужен стек, а не целый вектор - используйте stack

## Поиск в отсортированном векторе
Проверка на существование:
binary_search(begin(v), end(v), x)
Первый элемент, больший или равный данному:
lower_bound(begin(v), end(v), x)
Первый элемент, больший данного:
upper_bound(begin(v), end(v), x)
Диапазон элементов, равных данному:
equal_range(begin(v), end(v), x) == make_pair(lower_bound(...), uppder_bound(...))

## equal_range
Если элемент есть, equal_range = [lower_bound, upper_bound] - диапазон всех вхождений
Если элемента нет, lower_bound == upper_bound - позиция, куда можно вставить элемент без нарушения порядка сортировки
Найти количество вхождений - upper_bound - lower_bound
Как перебрать все вхождения - проитерироваться от lower_bound до upper_bound

Вместо алгоритмов лучше использовать именно методы, если они есть у контейнера




