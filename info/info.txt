
## Потоковые манипуляторы

#include <iomanip>
setw - задать ширину поля ввода
setprecision - точность вывода вещественных чисел
setfill - заполнитель для setw
left - выравнивание данных по левому краю
fixed - выведение чисел в фиксированном формате

## Ввод и вывод пользовательских типов
// оператор вывода в поток
ostream& operator<<(ostream &s, Obj &o)
// оператор ввода из потока
istream& operator>>(istream &s, Obj &o)

## Удобное использование пользовательских типов
??? operator ???(???)
bool operator <(const &Tobj lhs, const &Tobj rhs)
Tobj operator +(const &Tobj lhs, const &Tobj rhs)

## Удобный способ сообщить о проблеме: exception, runtime_error, ...
try
{
    // опасный код
}
catch (const exception &e)
{
    // обработка ошибки
    // e.what() возвращает текст ошибки
}

## Кортежи:
- Упрощают реализацию operator<
- Позволяют вернуть несколько значений из функции и сохранить их
Пары - частный случай кортежей, но чуть приятнее

## structure bindings
tuple<bool, string> FindCountry()
{
    return {false, "Not exist"};
}

auto [success, message] = FindCountry();

## Вставка в произвольное место вектора
v.insert(it, value) вставляет value перед итератором it:
v.insert(v.end(), value) вставит value перед end

v.insert(it, range_begin, range_end)
вставляет диапазон [range_begin, range_end] в позицию it
v.insert(it, count, value)
count раз вставляет элемент value в позицию it
v.insert(it, {1, 2, 3})
вставляет 1, 2, 3 в позицию it

## Обратные итераторы
Упрощают итерирование по контейнеру в обратную сторону
sort(rbegin(v), rend(v)) - сортировка вектора по убыванию

## Справочник по C++ - https://ru.cppreference.com/w/
## Алгоритмы C++ - https://ru.cppreference.com/w/cpp/algorithm

## Категории итераторов
Input: итераторы любых контейнеров
Forward, Bidir: итераторы любых контейнеров (кроме set и map, если нужно менять содержимое)
Random: итераторы векторов и строк
Output: итераторы векторов и строк, inserter, back_inserter
Полный список требований к input-итераторам: https://en.cppreference.com/w/cpp/named_req/InputIterator
Полный список требований к output-итераторам: https://en.cppreference.com/w/cpp/named_req/OutputIterator
Полный список требований к forward-итераторам: https://en.cppreference.com/w/cpp/named_req/ForwardIterator
Полный список требований к bidirectional-итераторам: https://en.cppreference.com/w/cpp/named_req/BidirectionalIterator
Полный список требований к итераторам произвольного доступа: https://en.cppreference.com/w/cpp/named_req/RandomAccessIterator
Полный список требований к contiguous-итераторам: https://en.cppreference.com/w/cpp/named_req/ContiguousIterator
next замещает it + 1 или it + n;
prev замещает it - 1 или it - n;
advance замещает it += n;
distance замещает it2 - it1.
vector<bool> устроен так, что каждый элемент занимает в нём не один байт (как одна переменная типа bool), а один бит

## Дек - очередь
#include <deque>
d.push_back(x), d.pop_back()
d.push_front(x) - добавление в начало
d.pop_front() - удаление из начала
d[i] - обращение по индексу
Дек умеет больше, чем вектор, поэтому менее эффективен.
Если нужно только записывать и удалять из конца, то использовать вектор

## Очередь
#include <queue>
Умеет совсем немного:
q.push(q), q.pop() - добавляет в конец и удаляет из начала
q.front(), q.back()
q.size(), q.empty()
по данному контейнеру нельзя проитерироваться

## Стэк
#include <stack>
Позволяет лишь добавлять в конец и удалять из конца
Как вектор, но умеет меньше:
st.push(x), st.pop()
st.top()
st.size(), st.empty()

Если нужен вектор с добавлением в начало или удалением из начала, используйте deque
Нужна лишь очередь - используйте queue
Нужен стек, а не целый вектор - используйте stack

## Поиск в отсортированном векторе
Проверка на существование:
binary_search(begin(v), end(v), x)
Первый элемент, больший или равный данному:
lower_bound(begin(v), end(v), x)
Первый элемент, больший данного:
upper_bound(begin(v), end(v), x)
Диапазон элементов, равных данному:
equal_range(begin(v), end(v), x) == make_pair(lower_bound(...), uppder_bound(...))

## equal_range
Если элемент есть, equal_range = [lower_bound, upper_bound] - диапазон всех вхождений
Если элемента нет, lower_bound == upper_bound - позиция, куда можно вставить элемент без нарушения порядка сортировки
Найти количество вхождений - upper_bound - lower_bound
Как перебрать все вхождения - проитерироваться от lower_bound до upper_bound

Вместо алгоритмов лучше использовать именно методы, если они есть у контейнера

remove_if – оставляет в начале вектора элементы, не удовлетворяющие условию;
unique – оставляет в начале вектора по одному элементу из группы подряд идущих
повторений;
min_element, max_element, minmax_element – min, max элементы;
all_off – проверка условия для всех элементов.

sort(rbegin(langs), rend(langs)); – простой способ сортировки вектора по убыванию

Выведем позиции всех пробелов в строке:
for (auto it = find(begin(s), end(s), ' ');
it != end(s);
it = find(next(it), end(s), ' ')) { // переходим в цикле к следующему пробелу
cout << it − begin(s) << " "; // next(it) эквивалентен it + 1
}

## Макросы
Оператор # вставляет в код строковое представление параметра макроса
Макросы __FILE__ и __LINE__ автоматизируеют формирование сообщения для ассерта
Если ваш макрос не используется __FILE__, __LINE__ или #, подумайте, можно ли обойтись без него
Если всё же пишите макрос: старайтесь использовать каждый аргумент только один раз,
старайтесь максимально изолировать аргументы с помощью скобок

## Порождающие функции
Преимущества:
- сокращают код, перекладывая на компилятор вывод параметров шаблона
Недостатки:
- их нужно писать самому
- auto full = MakeRange(t.begin(), t.end()) - неочевиден тип переменной full

## Вывод типов в шаблонах классов в C++17
Если в классе есть конструктор, позволяющий определить тип шаблона, компилятор
выводит его сам:
template <class T>
struct Widjet
{
    Widjet(T value);
};
Widjet w_int(5);    // Widjet<int>
Widjet w_char('a'); // Widjet<char>

Явное указание типа шаблона может быть громоздким
Есть два способа возложить вывод типа на компилятор:
1. Порождающая функция
2. Конструктор, принимающий параметры всех шаблонных типов

По умолчанию при инстанцировании стоит явно указывать шаблонный тип
Если это неудобно, попробовать второй способ - в нём явно указано имя шаблона
IteratorRange second_half(t.begin(), t.end() / 2, t.end());
pair p(true, t.begin());
Если он не подходит, делаем порождающую функцию:
auto p = make_pair(5, bool);

В качестве возвращаемого типа функции можно использовать ключевое слово auto
Оно говорит компилятору: "Возьми тип из команды return"
По умолчанию следует явно указывать тип результата функции
Использовать auto в качестве типа результата функции стоит только если:
- типа результата громоздкий
- тело функции очень короткое
В противном случае может пострадать понятность кода

Код не бывает просто быстрым или медленным
Он бывает достаточно быстрым для своей задачи

Как правило код надо стараться делать правильным, простым, а только потом быстрым
Это не значит, что о производительности вообще не надо думать

Избегайте преждевременной оптимизации

Принцип Парето
80% времени работы программы тратится на исполнение 20% кода
Эти 20% и надо оптимизировать, но сначали их надо найти

Недостатки преждевременной оптимизации:
- необоснованное усложнение кода
- усложнение поддержки кода
- замедление разработки

Дональд Кнут:
Преждевременная оптимизация это корень всех зол

Уильям Вульф:
Во имя эффективности, которая при этом не всегда достигается, совершается гораздо
больше грехов, чем по любой другой причине, включая полную глупость

Прежде, чем ускорять код, замерьте сколько он работает
Если это недостаточно быстро, начинайте искать узкие места
Интуиция не работает - измеряйте!

ofstream не сразу выводит в файл, а буферизирует выведенные в него данные
cout и cerr ведут себя точно так же
Манипулятор endl не только выводит перевод строки, но и сбрасывает буфер потока в файл

Когда использовать endl:
В ситуациях, Когда
- скорость не так важна
- важно сразу видеть результата
Примеры:
- LogDuration
- TestRunner::RunTest

Когда использовать \n:
- в программах stdin -> stdout

Связанность стандартных потоков
По умолчанию потоки cout и cerr связаными с потоком cin
Перед каждой операцией ввода их буферы сбрасываются
Это может замедлять программы типа stdint -> stdout
наряду с заменой \n на endl добавляйте cin.tie(nullptr) в начало своих программ
команда ios_base::sync_with_stdio(false) может ещё больше ускорить программу,
но вызывать её нужно до всех команд ввода/вывода, иначе программа может работать непредсказуемо

Для программ тип stdin -> stdout рекомендуется не использовать endl
А также в самое начало добавлять код
ios_base::sync_with_stdio(false)
cin.tie(nullptr)

Сложность изученных алгоритмов:
Константная (1):
- арифметические операции
- обращение к элементу вектора
Логарифмитическая (LogN):
- двоичный поиск (lower_bound и пр.)
- поиск в set или map
Линейная (N):
- цикл for (с лёгкими итерациями)
- алгоритмы find_if, min_element и пр.
NlogN:
- алгоритм set (с лёгкими итерациями)
Часто используют O-символику:
O(N), O(NlogN) и т.д.

for (int &x :numbers_to_find)
{
    lower_bound(begin(v), end(v), x);
    x *= 2;
}
Сколько работает такой код?
numbers_to_find.size() * (log(v.size()) + 1)
Простая математика: сложение и умножение

Сравнение алгоритмов:
1 < logN < N < NlogN < N^2
При сложении большее поглощает меньшее:
O(N) + O(logN) = O(N)
O(5N) и O(8N) надо сравнивать измерениями
Геометрические и графические задачи могут иметь очень большую константу в сложности

Как оценить время работы?
Рассматриваем худший случай
Вычисляем количество операций при максимальном N
Умножаем на константу ~ 10-50
Очень грубо оценили количество операций
За секунду можно успеть 10^9
Измеряйте конкретный алгоритм на больших данных!

## Модель памяти
В модели памяти C++ есть два источника памяти:
- Стек
- Куча
В стеке размещаются локальные переменные функции
В куче - объекты, которые должны жить дольше, чем создавшая их функция

Для создания объектов в куче используется оператор new (возвращает указатель)
Инициализация объектов, созданных в куче, выполняется так же, как для объектов на стеке
int *pInt = new int; - значение не определено
string *pString = new string; - значение не определено

int *pInt = new int(42); - значение определено
string *pString = new string("Hi"); - значение определено

Оператор delete позволяет освободить память, выделенную через new
Если этого не делать, возникает утечка памяти
Моделирование утечки памяти:
#include <random>
int n = 0;
cin >> n;
mt19937_64 random_gen{};
uint64_t sum = 0U;
for (int i = 0; i < n; ++i)
{
    auto x = new uint64_t;
    *x = random_gen();
    sum += *x;
    delete x; // если убрать строчку, то произойдёт утечка памяти
              // (забьётся всё ОЗУ, если подать достаточно большое n)
}
cout << sum;

delete не только освобождает память, но и вызывает деструктор класса

Для создания в куче N объектов типа T используется оператор new T[N]
Для их освобождения используется оператор delete[]
Если вместо delete[] вызвать delete, программа может работать некорректно

Стек - это область оперативной памяти
Прибавление числа X к указателю на тип T изменяет его адрес на X * sizeof(T)
При выполнении арифметики указателей не выполняется контроль доступа
Если p имеет тип T*, то записи *(p + 5) и p[5] эквивалентны

Пары методов begin и end для контейнера:
T *begin() { return data; }
T *end() { return _end; }
const T *begin() const { return data; }
const T *end() const { return _end; }

const T *ptr - Указатель на константу
T *const ptr - Константный указатель
const T *const ptr - Константный указатель на константу

vector
capacity - количество элементов, умещающихся в памяти вектора
при push_back может выделяться память
reserve позволяет зарезервировать достаточное количество памяти и сэкономить
на реаллокациях
shrink_to_fit позволяет сэкономить память, получив capacity == size

Указатели и ссылки на элементы вектора могут инвалидироваться при изменении
его размера
Дек не обладает такой проблемой
Защита от инвалидации - использовании дека или хранение индексов вместо
указателей

Вектор или Дек?
Вектор:
- быстрое обращение к элементу
- быстрое итерирование
Дек:
- быстрая серия push_back при неизвестном заранее размере
- быстрая вставка в начало
- неинвалидация ссылок

Инвалидация итераторов
Итераторы в целом мощнее указателей
Итераторы вектора ожидаемо инвалидируются
Дек может сохранять указатели валидными, но с итераторами всё гораздо
сложнее
Дек может уберечь ссылки от инвалидации, но не может убереть итераторы

Список (list)
Достоинства:
- быстрое удаление из середины
- неинвалидация ссылок и итераторов при удалении
Недостатки:
- невозможность быстро обратиться к элементу по индексу
- выделение памяти под каждый элемент

Методы списка
Константные (O(1)):
- size, empty
- push_back, pop_back
- push_front, pop_front
- insert, erase от итераторов
Линейные: reverse, unique, remove, remove_if
Сортировка за O(NLogN): метод sort

Итоги
Список эффективен, если необходимо удалять из середины (или вставлять
в середину) быстро и не инвалидируя итераторы
Итераторы списка имеют категорию bidirectional
На практике списки нужны редко
Ещё реже нужен контейнер forward_list - список, позволяющий итерироваться
только вперёд

string_view позволяет сослаться на диапазон символов, не владея им
Позиции более уместны при работе со string и string_view, чем итераторы
Методы remove_prefix и remove_suffix позволяют удобно итерироваться по string_view

Итерирование с remove_prefix:
vector<string_view> SplitIntoWords(string_view str)
{
    vector<string_view> result;

    if (str.empty())
    {
        return {};
    }
    else if (str[0] == ' ')
    {
        size_t not_space = str.find_first_not_of(' ');
        str.remove_prefix(not_space);
    }

    while (true)
    {
        size_t space = str.find(' ');
        result.push_back(str.substr(0, space));
        if (space == str.npos)
        {
            break;
        }
        else
        {
            str.remove_prefix(space + 1);
            // ищем лишние пробелы, так как их может быть больше одного
            size_t not_space = str.find_first_not_of(' ');
            if (not_space == str.npos)
            {
                break;
            }
            str.remove_prefix(not_space);
        }
    }
    return result;
}

Move
Чтобы использовать функцию move, нужно подключить модуль utility

Если у объекта нет данных в куче, а основные данные на стеке, то данные придётся копировать

Вызов move для константного объекта бесполезен. Следите за константностью перемещаемого
объекта

Когда может возникнуть перемещение
Инициализация и присваивание
Помещение в контейнер:
- vector<T>::push_back,
  vector<T>::insert
- deque<T>::push_back,
  deque<T>::push_front, deque<T>::insert
- set<T>::insert, map<K, V>::operator[]
- и другие методы, копирующие аргументы

Функция move позволяет инициировать перемещение там, где случилось бы
копирование
Сама функция move не перемещает, она лишь заставляет компилятор переместить
Как правило, после перемещения объект остаётся пустым

Если у объекта много данных на стеке, перемещение не поможет или поможет плохо
Вызов move для константного объекта бесполезен. Следите за константностью
перемещаемого объекта

Копирование и присваивание для собственнных типов:
- при необходимости компилятор сам генерирует конструктор копирования и присваивания,
которые просто копируют все поля
- нужно писать собственные конструкторы копирования и присваивания для типов, которые управляют памятью, например, SimpleVector

class Logger
{
public:
    Logger() { cout << "Default ctor\n"; }
    Logger(const Logger &) { cout << "Copy ctor\n"; }
    void operator=(const Logger &) { cout << "Copy assignment ctor\n"; }
    Logger(Logger &&) { cout << "Move ctor\n"; }
    void operator=(Logger &&) { cout << "Move assignment ctor\n"; }
};

template <typename T>
SimpleVector<T>::SimpleVector(const SimpleVector<T> &other)
    : data(new T[other.capacity]),
      size(other.size),
      capacity(other.capacity)
{
    copy(other.cbegin(), other.cend(), begin());
}

Конструктор перемещения:
vector<int> source = /* ... */;
vector<int> target = move(source);
vector<int> target2(move(target));

vector<vector<int>> vectors;
vectors.push_back(vector<int>(5));
Во всех случаях вызывается конструктор перемещения
(move constructor)

Оператор перемещающего присваивания:
vector<int> source = /* ... */;
vector<int> target = /* ... */;
target = move(source);
target = vector<int>(5);
В обоих случаях вызывается оператор перемещающего присваивания
(move assignment operator)

rvalue-ссылки
Перегрузка по rvalue-ссылке - способ отличить временный объект от постоянного
target = source;         // вызывается operator=(const vector<int> &)
target = vector<int>(5); // вызывается operator=(vector<int> &&)
target = move(source);   // вызывается operator=(vector<int> &&)

Если метод должен принять объект и положить его в контейнер,
принимайте параметр по значению:
void Objects::Add(Object object)
{
    data.insert(move(object));
}
Временный объект перместится в object, а оттуда - в контейнер (два перемещения)
Постоянный объект скопируется в object, а оттуда переместится в контейнер

Перемещение в push_back
vector<T>::push_back(const T&)
вызывает T::T(const T &), копируя свой аргумент
vector<T>::push_back(T &&)
вызывает T::T(T&&), перемещая свой аргумент

Перемещение в методах контейнеров
Если одна из версий метода принимает rvalue-ссылку,
метод умеет перемещать свой аргумент

Если обернуть итератор в make_move_iterator, вместо копирования из него
будет перемещение
Примеры: merge, set_intersection и пр.
Вместо copy от move-итераторов можно использовать алгоритм move
Можно оптимизировать сортировку слияниями

Существуют типы, которые нельзя копировать, например, потоки ввода и вывода
Разрешено только перемещение
Попытка их скопировать порождает ошибку "use of deleted function..."

В некоторых случаях компилятор опускает перемещение и копирование:
- возврат из функции временного объекта (copy elision)
- инициализация временным объектом (copy elision)
- возврат из функции локальной переменной (NRVO - named return value optimization)

Базовая многопоточность
#include <future>

int SumTwoVectors(const vector<int> &one, const vector<int> &two)
{
    future<int> f = async([&one]
    {
        return accumulate(one.begin(), one.end(), 0);
    });
    int result = accumulate(two.begin(), two.end(), 0);
    return result + f.get();
}

future<Костюм> талон = async([]{ return костюм; });

Костюм в химчистке обрабатывается асинхронно
Что можно делать с талоном:
- периодически приходить и узнавать, готов ли костюм
- сесть рядом с химчисткой и ждать, когда костюм будет готов
- обменять талон на костюм, когда его почистят

Талон - это future на чистый костюм

future<T>, созданный с помощью async, вызывает get() в своём деструкторе
Если результат вызова функции async не сохранить в переменную,
то программа может выполняться последовательно

Если запустить 7000 потоков на ноуте с 4-я логическими потоками,
то потоки начнут становиться в очередь, что только замедлит программу

Не всякая многопоточная программа быстрее однопоточной
Поэтому надо проводить измерения

Для защиты данных от состояния гонки используется класс mutex
Для захвата и освобождения мьютекса используется класс lock_guard<mutex>
Он захватывает мьютекс в конструкторе и освобождает в деструкторе

Для некоторых алгоритмов возможно включить их параллалельные версию с помощью указания
ExecutionPolicy: seq, par, par_unseq. Константы находятся в <execution>

// Коричневый пояс

Устройство ассоциативных контейнеров
Хэш-функция отображает объекты любого типа в числа
Когда хэш-функция отображает два различных объекта в одно число,
возникает коллизия

поиск элементов в unordered контейнерах состоит из двух этапов:
- сначала с помощью хэш-функции для объекта вычисляется индекс корзины
- и если корзина не пуста, то происходит поиск объекта по списку последовательно

Сложность операций
Вычисление хеш-функции - О(1)
Важно, чтобы хеш-функции были лёгкими

Поиск объекта в корзине. В среднем - О(1)
Для этого нужно, чтобы цепочки не были длинными

Сложность операций unordered_map / unordered_set:
find   O(1) (в среднем)
insert O(1) (в среднем)
delete O(1) (в среднем)

map/set
Каждый инкремент/декремент стоит O(1) в среднем
Итераторы в map/set - двунаправленные
Нужно пользоваться встроенными методами для поиска:
find, lower_bound, uppder_bound

Итераторы в unordered-контейнерах
Каждый инкремент стоит О(1)
Итераторы - последовательные (Forward Iterator)
При вставке элемента нужно быть осторожным - существующие итераторы
могут инвалидироваться

Ассоциативные контейнеры обеспечивают быстрый поиск элементов.
Примером ассоциативных структур данных являются множество и словарь,
которым соответствуют типы set и map.
Тип set позволяет хранить уникальные объекты различных типов,
эффективно добавлять, удалять объекты и выполнять поиск

Чтобы поместить произвольный тип в set/map, необходимо
определить для него оператор "меньше" <
Чтобы поместить произвольный тип в unordered-контейнер, необходимо
определить для него хеш-функцию и оператор сравнения ==

Качество хеш-функции существенно влияет на производительность
хеш-таблицы
Хорошая хеш-функция охватывает широкий диапазон корзин и распределяет
элементы по ним равномерно

Рекомендации по выбору хеш-функции
Использование стандартных хешеров hash<T>
Полиномиальные хеш-функции
Помните, что хеш-функция должна равномерно распределять элементы
по корзинкам

Хеш-функция для структуры Plate (номер автомобиля):
struct Plate
{
    char c1;
    int number;
    char c2;
    char c3;
    int region;
};
struct PlateHasher()
{
    size_t operator()(const Plate &p) const
    {
        size_t result = p.number;
        result *= 100;
        result += p.region;

        int s1 = p.c1 - 'A';
        int s2 = p.c2 - 'A';
        int s3 = p.c3 - 'A';
        int s = (s1 * 100 + s2) * 100 + s3;

        result *= 1'000'000;
        result += s;

        return result;
    }
};

Хеш-функция для структуры MyType:
struct MyType
{
    double d;
    string str;
    Plate plate;
};
struct MyTypeHasher
{
    size_t operator()(const MyType &p) const
    {
        size_t r1 = dhash(p.d);
        size_t r2 = shash(p.str);
        size_t r2 = phash(p.plate);

        // Ax^2 + Bx + C
        static constexpr size_t X = 37U;

        return r1 * X * X + r2 * X + r3;
    }

    hash<double> dhash;
    hash<string> shash;
    PlateHasher phash;
};

Нельзя напрямую изменять ключ объекта в set
Можно скопировать во временный объект и обратно
Чтобы избежать промежуточных копирований, используйте
extract и insert
При необходимости перенести все элементы из одного дерева
в другое - используйте merge

Итоги
По умолчанию следует использовать unordered контейнеры
Когда важно иметь определённый порядок элементов при обходе - map и set

Идиома IILE (Immediately involve lymbda expression) может пригодиться для нетривиальной
инициализации константного объекта
Она удобна для замера времени инициализации
Не рекомендуется использовать auto при объявлении объекта

Лямбда-функция
int value = 5;
auto increase = [value](int x)
{
    return value + x;
}
эквивалентна классу с константным operator()
class <unnamed>
{
    int value;
public:
    int operator()(int x) const { return value + x; }
}
поэтому внутри лямбда-функции value имеет тип const value

Ключевое слово mutable
Позволяет изменять внутреннее состояние объекта, оставляя его методы константными
Константые методы гарантируют логическую константность
Физическая константность - ни один бит внутри объекта не меняется
Логическая константность - не меняется наблюдаемое состояние объекта

mutable = thread safe, в многопоточных программах
Поля типа mutex "хотят" быть mutable, потому что они потокобезопасны и не являются
частью наблюдаемого состояния объекта
const = thread safe

Рекомендации по использованию const
В многопоточных программах старайтесь организовывать конкурентный доступ к константным объектам
Если класс предназначен для использования в многопоточной среде, его mutable-поля должны быть потокобезопасны,
чтобы гарантировать, что const = thread safe

Симуляция нехватки памяти
Windows
appverif /verify pool.exe /faults 10000 200
Входит в Windows SDK
10000 - Вероятность ошибки выделения динамической памяти из 1'000'000 - для 10000 это 1%
200 - Задержка со старта программы, в течение которой она будет работать как обычно, в мсек

unique_ptr<T>
Сам удаляет объект в своём деструкторе
Его нельзя копировать, можно только перемещать (ведь он уникальный!)
Для доступа к сырому указателю используется метод get()
Создание:
auto ptr = unique_ptr<T>(new T);
или
auto ptr = make_unique<T>();

В качестве простого правила по умолчанию, деструктор следует объявлять виртуальным тогда и только тогда,
когда ваш класс содержит виртуальные функции.
При этом, если деструктор текущего класса уже является виртуальным в виду того,
что он был объявлен виртуальным в одном из базовых классов, повторно его делать виртуальным, конечно, не нужно.

unique_ptr:
- нельзя копировать, можно только перемещать
- всегда удаляет объект в деструкторе

shared_ptr:
- можно и копировать, и перемещать
- создаёт контрольный блок и подсчитывает ссылки
- удаляет объект и контрольный блок, когда количество ссылок падает до нуля

Виды объектов с точки зрения времени их жизни
Автоматические. Время жизни определяет компилятор
- локальные переменные
- глобальные переменные
- члены классов

Динамические. Время жизни определяет программист
- создаются с помощью new (вызывается неявно с помощью make_unique или make_shared())
- удаляются с помощью delete (вызывается неявно в деструкторе unique_ptr или shared_ptr)

Владение. Считается, что сущность "владеет" объектом, если она ответственна за его удаление

Владение автоматическими объектами:
- окружающий блок кода владеет локальными переменными
- сама программа владеет глобальными переменными
- объект класса владеет своими членами
Это правила, которым следует компилятор

Владение динамическими объектами:
- умный указатель владеет объектом, на который указывает
- unique_ptr - эксклюзивное (уникальное) владение
- shared_ptr - разделяемое (совместное) владение
- сырой указатель НЕ владеет объектом
Это соглашения, которым следует программист

Соглашение по владению динамическими объектами могут быть нарушены
- по ошибке
- по необходимости

В случае соблюдения соглашений
- не может быть утечек памяти
- не может быть двойного удаления объектов

Что нужно делать:
- не использовать new и delete
- для создания динамических объектов использовать функции make_unique() и make_shared()
- не использовать конструкторы умных указателей, принимающие сырой указатель

Существуют два вида объектов: автоматические и динамические
Владелец объекта ответственнен за его удаление
- владение автоматическими объектами описывают правила, которым следует компилятор
- владение динамическими объектами описывают соглашения, которым следует программист

Соглашения по владению динамическими объектами
- гарантируют отсутствие утечек памяти и двойного удаления
- могут быть нарушены по необходимости или по ошибке

Динамический объект удаляется, когда им перестают владеть умные указатели
Умные указатели можно присваивать:
- перемещающее присваивание
- копирующее присваивание
- присваивание nullptr

Многопоточность и shared_ptr:
- shared_ptr обеспечивает потокобезопасный доступ к контрольному блоку
- доступ к самому объекту никак не контролируется, он сам отвечает за корректное поведение в многопоточной среде
- простой способ обеспечить безопасность доступа к самому объекту - сделать shared_ptr на константный объект
- перемещение shared_ptr - оптимизация, чтобы исключить лишние атомарные изменения счётчика

weak_ptr
- из него можно создавать shared_ptr
- метод lock возвращает shared_ptr, который указывает на объект, если до этого уже был создан shared_ptr, иначе вернёт пустой shared_ptr
- если где-то в программе удалится последний shared_ptr, то удалится и объект, несмотря на то, что weak_ptr тоже указывает на этот объект,
потому что weak_ptr не владеет данными

class CacheWeak
{
public:
    shared_ptr<Widget> GetWidget(const string &name)
    {
        shared_ptr<Widget> ret = _map[name].lock();
        // если в программе ещё не создавался shared_ptr
        // для Widget с таким именем
        if (not ret)
        {
            ret = make_shared<Widget>(name);
            _map[name] = ret;
        }
        return ret;
    }
private:
    map<string, weak_ptr<Widget>> _map;
};

Пользовательский deleter позволяет выполнить произвольное действие вместо удаления объекта
- например, можно создать условно владеющий shared_ptr (хотя это нарушит соглашение по владению)
- доступен и для unique_ptr, но работает немного по-другому

Widget * GetNonOwningPtr();
shared_ptr<Widget> GetOwningPtr();

shared_ptr<Widget> GetWidget(bool owning)
{
    if (owning)
    {
        return GetOwningPtr();
    }
    else
    {
        Widget *ptr = GetNonOwningPtr();
        auto dummyDeleter = [](Widget *){};
        return shared_ptr<Widget>(ptr, dummyDeleter);
    }
}

----- RAII -----
Исключения
Если произошло исключение, то текущий блок аварийно покидается
Для всех созданных автоматических переменных вызываются деструкторы (как если бы блок просто закончился)
Это называется раскруткой стека

Можно генерировать исключения в конструкторах: такой объект не считается созданным, для него не будет вызван деструктор
Генерировать исключения, покидающие пределы деструкторов, запрещено. Считается, что все деструкторы должны отработать без сбоя
Представьте, что будет, если в деструкторе во время раскрутке стека произойдет исключение

Для автоматических объектов гарантированно будет вызван деструктор при любом способе выхода из блока
То же относится и к вложенным полям объектов

RAII = Resourse Aquisition Is Initialization
(получение ресурса есть инициализация)

Ресурс предоставляется напрокат третьей стороной (например, ОС), и его обычно нужно вернуть. Примеры: память, файл, мьютекс

Идиома RAII предлагает связывать с каждым таким ресурсом определённый автоматический объект

Оборачивайте ресурсы в классы
В деструкторах этих классов возвращайте захваченные ресурсы обратно

Как передавать параметры в функции:
- пара итераторов или контейнер
- с c++20 контейнер или range
- вместо указателя на данные и количество - std::span

При возвращении из функции типа с большим количеством данных на стеке удобно оборачивать этот тип в unique_ptr, переселяя в кучу

Возвращение нескольких объектов с разными типами из функции:
- пары и кортежи - хорошо, структуры с понятными названиями полей - ещё лучше
- не забывайте про move - {move(val1), move(val2)}



Изменяемые параметры функций тяжело отличить от остальных в месте вызова.
Это исправляется передачей по указателю или по значению с возвращением нового состояния изменяемого объекта.

Поддерживайте функции небольшими и компактными.
Если функция достаточно велика, изменяемые параметры могут доставлять значительные неудобства.
Есть различные способы снизить эти неудобства: разделить функцию на несколько,
объединить несколько параметров в один прокси-объект или переписать функцию так,
чтобы вместо совершения определённых действий над объектом она возвращала набор описаний этих действий.
При этом важно понимать, что эти преобразования раздувают код и поэтому целесообразны только для достаточно больших проектов и функций,
которые нельзя легко разбить на несколько. Простым небольшим функциям изменяемые параметры не вредят, но и злоупотреблять ими не стоит.

Есть несколько способов повысить прозрачность и тестируемость неконстантных методов:
- писать их понятно и компактно
- выселять сложную логику в статические методы, покрывая их юнит-тестами
- объединять поля в подклассы

inserter и back_inserter

Напомним, что в качестве выходного итератора можно передать специальный back_insert_iterator, при записи в который происходит push_back в указанный контейнер:
vector<T> result;
merge(/* ... */, back_inserter(result));
// результат лежит в векторе result

Для вызова метода insert — например, для множества — существует insert_iterator, создаваемый с помощью функции inserter:
set<T> result;
merge(/* ... */, inserter(result, end(result)));
// результат лежит во множестве result

С помощью ostream_iterator можно вывести элементы контейнера в поток с помощью вызова copy:
vector<int> numbers = {2, 1, 9, 2};
copy(begin(numbers), end(numbers), ostream_iterator<int>(cout, " "));

Для возврата из функции набора объектов без передачи владения ими есть следующие варианты:
- Вернуть ссылку на контейнер: не очень гибко и нарушает инкапсуляцию.
- Вернуть span или string_view: неплохо, но подходит только для определённых контейнеров.
- Вернуть самописный Range из двух итераторов (или дождаться C++20 и использовать ranges): максимально гибко, но иногда подойдут и более простые варианты.

Если же функция возвращает набор объектов с передачей владения, градация вариантов от простого к сложному следующая:
- Вернуть контейнер: просто и понятно, но расходует память под хранение элементов.
- Принять выходной итератор, записать в него и вернуть новое состояние: совместимо со стандартной библиотекой,
но немного громоздко в месте вызова и тяжело кастомизируемо под сложные ситуации.
- Принять callback, потребляющий элементы: несовместимо со стандартной библиотекой и громоздко для простых случаев, но легко кастомизируемо.

Оператор неявного преобразования:
class ReadingManagerBuilder {
public:
  ReadingManagerBuilder& SetMaxUserCount(int max_user_count);
  ReadingManagerBuilder& SetMaxPageCount(int max_page_count);
  ReadingManagerBuilder& SetCheerFactor(double cheer_factor);

  operator ReadingManager() const {
    return {};
  }
};
ReadingManager manager =
    ReadingManagerBuilder()
    .SetMaxUserCount(10000)
    .SetMaxPageCount(500)
    .SetCheerFactor(2);

Принимать в конструкторе ReadingManager структуру, созданную с помощью designated initializers
ReadingManager manager(ReadingManagerParams{
    .max_user_count = 10000,
    .max_page_count = 500,
    .cheer_factor = 2
});

Ещё один способ создания подобных типов, принятый в том числе и в стандартной библиотеке, — определение специальных суффиксов, позволяющих писать так:
const Query query = ParseQuery(
    text, CountryId(225),
    7_words, 23_letters, 20_forms,
    true, false, false
);
Определение таких суффиксов возможно благодаря так называемым user-defined literals и осуществляется с помощью operator"":
auto operator""_words(unsigned long long value) {
  return MaxWordCount(value);
}

Существует несколько способов борьбы с громоздкостью и запутанностью списка параметров функции:
- Сгруппировать параметры в структуры.
- Сделать функцию методом класса, унеся глобальный контекст из параметров функции в поля класса.
- Использовать enum для булевых параметров: свой для каждого или один общий — с маской.
- Определять отдельные типы для числовых параметров, снабжая их explicit-конструкторами или другими способами явного создания при вызове функции.

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ЧЁРНЫЙ ПОЯС !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
Санитайзеры
add_project_arguments('-D_GLIBCXX_DEBUG', language: 'cpp')
add_project_arguments('-D_GLIBCXX_ASSERTIONS', language: 'cpp')
add_project_arguments('-D_GLIBCXX_DEBUG_PEDANTIC', language: 'cpp')

Включение санитайзера под линукс:
default_options add 'b_sanitize=address,undefined'

// для расшифровки непонятных адресов
add_project_arguments('-g', language: ['c', 'cpp'])
add_project_arguments('-fno-omit-frame-pointer', language: ['c', 'cpp'])
add_project_arguments('-fno-optimize-sibling-calls', language: ['c', 'cpp'])
// ещё надо подставить путь к symbolizer при запуске программы
// !!! оказывается эти шаги не нужны, так как и так выводится при падении программы, на какой строчке main.cpp она упала

Подробнее про дебажные дефайны
Названия дебажных дефайнов зависят от используемой вами стандартной библиотеки:
    В libstdc++ включайте _GLIBCXX_DEBUG и _GLIBCXX_DEBUG_PEDANTIC, как продемонстрировано в видео.
    В libc++ включайте _LIBCPP_DEBUG=1.

Если вы не уверены относительно используемой реализации стандартной библиотеки, включайте все указанные макроопределения.

Ниже кратко описаны основные проверки, выполняемые в libc++ при включённом _LIBCPP_DEBUG=1.
Итераторы
    Разыменование end-итератора (итератора, указывающего за конец контейнера).
    Разыменование инвалидированного итератора.
    Увеличение end-итератора и уменьшение begin-итератора.
    += или -= к итератору, выводящие его за границы контейнера.
    Вычитание итераторов, принадлежащих разным контейнерам.

Контейнеры
    Вызов методов insert, erase и пр. с итератором, не принадлежащим текущему контейнеру.
    Конструирование строки от нулевого указателя.

Алгоритмы
    Проверка того, что при x < y неверно y < x. (Помогает не написать компаратор x <= y вместо x < y.)

В дополнение к описанным выше проверкам libstdc++ c _GLIBCXX_DEBUG проверяет корректность входа стандартных алгоритмов:
    Корректность диапазонов итераторов (когда это возможно проверить — например, для random access).
    Упорядоченность диапазона, передаваемого в lower_bound: а именно, что все элементы начала диапазона меньше искомого значения,
    а остальные не меньше. (Аналогично для upper_bound, equal_range и binary_search.)
    Упорядоченность диапазонов, передаваемых в merge, includes, set_*.

Pedantic-режим нельзя назвать богатым проверками, приведём лишь один пример.
При обращении к элементу строки по индексу в режиме _GLIBCXX_DEBUG проверяется, что индекс не больше длины строки,
так как стандартом гарантируется, что по индексу size() находится нулевой символ; в режиме _GLIBCXX_DEBUG_PEDANTIC индекс должен быть строго меньше длины строки.

Использование под Windows
Как было продемонстрировано в видео, дебажные дефайны включаются под Windows без каких-либо проблем.
Однако при попытке обнаружить место падения отладчиком вы можете столкнуться с тем, что при нарушении некоторого инварианта программа молча аварийно завершается,
не показывая стек вызовов функций.
В этом случае после старта отладки, но до запуска самой программы под отладчиком необходимо ввести в консоль отладчика (debugger console) следующую команду: break abort
(или более короткий вариант — b abort).
Благодаря этой команде отладчик «поймает» момент аварийного завершения (abort) программы, и вы увидите стек вызовов.

