
## Потоковые манипуляторы

#include <iomanip>
setw - задать ширину поля ввода
setprecision - точность вывода вещественных чисел
setfill - заполнитель для setw
left - выравнивание данных по левому краю
fixed - выведение чисел в фиксированном формате

## Ввод и вывод пользовательских типов
// оператор вывода в поток
ostream& operator<<(ostream &s, Obj &o)
// оператор ввода из потока
istream& operator>>(istream &s, Obj &o)

## Удобное использование пользовательских типов
??? operator ???(???)
bool operator <(const &Tobj lhs, const &Tobj rhs)
Tobj operator +(const &Tobj lhs, const &Tobj rhs)

## Удобный способ сообщить о проблеме: exception, runtime_error, ...
try
{
    // опасный код
}
catch (const exception &e)
{
    // обработка ошибки
    // e.what() возвращает текст ошибки
}

## Кортежи:
- Упрощают реализацию operator<
- Позволяют вернуть несколько значений из функции и сохранить их
Пары - частный случай кортежей, но чуть приятнее

## structure bindings
tuple<bool, string> FindCountry()
{
    return {false, "Not exist"};
}

auto [success, message] = FindCountry();

## Вставка в произвольное место вектора
v.insert(it, value) вставляет value перед итератором it:
v.insert(v.end(), value) вставит value перед end

v.insert(it, range_begin, range_end)
вставляет диапазон [range_begin, range_end] в позицию it
v.insert(it, count, value)
count раз вставляет элемент value в позицию it
v.insert(it, {1, 2, 3})
вставляет 1, 2, 3 в позицию it

## Обратные итераторы
Упрощают итерирование по контейнеру в обратную сторону
sort(rbegin(v), rend(v)) - сортировка вектора по убыванию

## Справочник по C++ - https://ru.cppreference.com/w/
## Алгоритмы C++ - https://ru.cppreference.com/w/cpp/algorithm

## Категории итераторов
Input: итераторы любых контейнеров
Forward, Bidir: итераторы любых контейнеров (кроме set и map, если нужно менять содержимое)
Random: итераторы векторов и строк
Output: итераторы векторов и строк, inserter, back_inserter
Полный список требований к input-итераторам: https://en.cppreference.com/w/cpp/named_req/InputIterator
Полный список требований к output-итераторам: https://en.cppreference.com/w/cpp/named_req/OutputIterator
Полный список требований к forward-итераторам: https://en.cppreference.com/w/cpp/named_req/ForwardIterator
Полный список требований к bidirectional-итераторам: https://en.cppreference.com/w/cpp/named_req/BidirectionalIterator
Полный список требований к итераторам произвольного доступа: https://en.cppreference.com/w/cpp/named_req/RandomAccessIterator
Полный список требований к contiguous-итераторам: https://en.cppreference.com/w/cpp/named_req/ContiguousIterator
next замещает it + 1 или it + n;
prev замещает it - 1 или it - n;
advance замещает it += n;
distance замещает it2 - it1.
vector<bool> устроен так, что каждый элемент занимает в нём не один байт (как одна переменная типа bool), а один бит

## Дек - очередь
#include <deque>
d.push_back(x), d.pop_back()
d.push_front(x) - добавление в начало
d.pop_front() - удаление из начала
d[i] - обращение по индексу
Дек умеет больше, чем вектор, поэтому менее эффективен.
Если нужно только записывать и удалять из конца, то использовать вектор

## Очередь
#include <queue>
Умеет совсем немного:
q.push(q), q.pop() - добавляет в конец и удаляет из начала
q.front(), q.back()
q.size(), q.empty()
по данному контейнеру нельзя проитерироваться

## Стэк
#include <stack>
Позволяет лишь добавлять в конец и удалять из конца
Как вектор, но умеет меньше:
st.push(x), st.pop()
st.top()
st.size(), st.empty()

Если нужен вектор с добавлением в начало или удалением из начала, используйте deque
Нужна лишь очередь - используйте queue
Нужен стек, а не целый вектор - используйте stack

## Поиск в отсортированном векторе
Проверка на существование:
binary_search(begin(v), end(v), x)
Первый элемент, больший или равный данному:
lower_bound(begin(v), end(v), x)
Первый элемент, больший данного:
upper_bound(begin(v), end(v), x)
Диапазон элементов, равных данному:
equal_range(begin(v), end(v), x) == make_pair(lower_bound(...), uppder_bound(...))

## equal_range
Если элемент есть, equal_range = [lower_bound, upper_bound] - диапазон всех вхождений
Если элемента нет, lower_bound == upper_bound - позиция, куда можно вставить элемент без нарушения порядка сортировки
Найти количество вхождений - upper_bound - lower_bound
Как перебрать все вхождения - проитерироваться от lower_bound до upper_bound

Вместо алгоритмов лучше использовать именно методы, если они есть у контейнера

remove_if – оставляет в начале вектора элементы, не удовлетворяющие условию;
unique – оставляет в начале вектора по одному элементу из группы подряд идущих
повторений;
min_element, max_element, minmax_element – min, max элементы;
all_off – проверка условия для всех элементов.

sort(rbegin(langs), rend(langs)); – простой способ сортировки вектора по убыванию

Выведем позиции всех пробелов в строке:
for (auto it = find(begin(s), end(s), ' ');
it != end(s);
it = find(next(it), end(s), ' ')) { // переходим в цикле к следующему пробелу
cout << it − begin(s) << " "; // next(it) эквивалентен it + 1
}

## Макросы
Оператор # вставляет в код строковое представление параметра макроса
Макросы __FILE__ и __LINE__ автоматизируеют формирование сообщения для ассерта
Если ваш макрос не используется __FILE__, __LINE__ или #, подумайте, можно ли обойтись без него
Если всё же пишите макрос: старайтесь использовать каждый аргумент только один раз,
старайтесь максимально изолировать аргументы с помощью скобок

## Порождающие функции
Преимущества:
- сокращают код, перекладывая на компилятор вывод параметров шаблона
Недостатки:
- их нужно писать самому
- auto full = MakeRange(t.begin(), t.end()) - неочевиден тип переменной full

## Вывод типов в шаблонах классов в C++17
Если в классе есть конструктор, позволяющий определить тип шаблона, компилятор
выводит его сам:
template <class T>
struct Widjet
{
    Widjet(T value);
};
Widjet w_int(5);    // Widjet<int>
Widjet w_char('a'); // Widjet<char>

Явное указание типа шаблона может быть громоздким
Есть два способа возложить вывод типа на компилятор:
1. Порождающая функция
2. Конструктор, принимающий параметры всех шаблонных типов

По умолчанию при инстанцировании стоит явно указывать шаблонный тип
Если это неудобно, попробовать второй способ - в нём явно указано имя шаблона
IteratorRange second_half(t.begin(), t.end() / 2, t.end());
pair p(true, t.begin());
Если он не подходит, делаем порождающую функцию:
auto p = make_pair(5, bool);

В качестве возвращаемого типа функции можно использовать ключевое слово auto
Оно говорит компилятору: "Возьми тип из команды return"
По умолчанию следует явно указывать тип результата функции
Использовать auto в качестве типа результата функции стоит только если:
- типа результата громоздкий
- тело функции очень короткое
В противном случае может пострадать понятность кода

Код не бывает просто быстрым или медленным
Он бывает достаточно быстрым для своей задачи

Как правило код надо стараться делать правильным, простым, а только потом быстрым
Это не значит, что о производительности вообще не надо думать

Избегайте преждевременной оптимизации

Принцип Парето
80% времени работы программы тратится на исполнение 20% кода
Эти 20% и надо оптимизировать, но сначали их надо найти

Недостатки преждевременной оптимизации:
- необоснованное усложнение кода
- усложнение поддержки кода
- замедление разработки

Дональд Кнут:
Преждевременная оптимизация это корень всех зол

Уильям Вульф:
Во имя эффективности, которая при этом не всегда достигается, совершается гораздо
больше грехов, чем по любой другой причине, включая полную глупость

Прежде, чем ускорять код, замерьте сколько он работает
Если это недостаточно быстро, начинайте искать узкие места
Интуиция не работает - измеряйте!

ofstream не сразу выводит в файл, а буферизирует выведенные в него данные
cout и cerr ведут себя точно так же
Манипулятор endl не только выводит перевод строки, но и сбрасывает буфер потока в файл

Когда использовать endl:
В ситуациях, Когда
- скорость не так важна
- важно сразу видеть результата
Примеры:
- LogDuration
- TestRunner::RunTest

Когда использовать \n:
- в программах stdin -> stdout

Связанность стандартных потоков
По умолчанию потоки cout и cerr связаными с потоком cin
Перед каждой операцией ввода их буферы сбрасываются
Это может замедлять программы типа stdint -> stdout
наряду с заменой \n на endl добавляйте cin.tie(nullptr) в начало своих программ
команда ios_base::sync_with_stdio(false) может ещё больше ускорить программу,
но вызывать её нужно до всех команд ввода/вывода, иначе программа может работать непредсказуемо

Для программ тип stdin -> stdout рекомендуется не использовать endl
А также в самое начало добавлять код
ios_base::sync_with_stdio(false)
cin.tie(nullptr)

Сложность изученных алгоритмов:
Константная (1):
- арифметические операции
- обращение к элементу вектора
Логарифмитическая (LogN):
- двоичный поиск (lower_bound и пр.)
- поиск в set или map
Линейная (N):
- цикл for (с лёгкими итерациями)
- алгоритмы find_if, min_element и пр.
NlogN:
- алгоритм set (с лёгкими итерациями)
Часто используют O-символику:
O(N), O(NlogN) и т.д.

for (int &x :numbers_to_find)
{
    lower_bound(begin(v), end(v), x);
    x *= 2;
}
Сколько работает такой код?
numbers_to_find.size() * (log(v.size()) + 1)
Простая математика: сложение и умножение

Сравнение алгоритмов:
1 < logN < N < NlogN < N^2
При сложении большее поглощает меньшее:
O(N) + O(logN) = O(N)
O(5N) и O(8N) надо сравнивать измерениями
Геометрические и графические задачи могут иметь очень большую константу в сложности

Как оценить время работы?
Рассматриваем худший случай
Вычисляем количество операций при максимальном N
Умножаем на константу ~ 10-50
Очень грубо оценили количество операций
За секунду можно успеть 10^9
Измеряйте конкретный алгоритм на больших данных!

## Модель памяти
В модели памяти C++ есть два источника памяти:
- Стек
- Куча
В стеке размещаются локальные переменные функции
В куче - объекты, которые должны жить дольше, чем создавшая их функция

Для создания объектов в куче используется оператор new (возвращает указатель)
Инициализация объектов, созданных в куче, выполняется так же, как для объектов на стеке
int *pInt = new int; - значение не определено
string *pString = new string; - значение не определено

int *pInt = new int(42); - значение определено
string *pString = new string("Hi"); - значение определено

Оператор delete позволяет освободить память, выделенную через new
Если этого не делать, возникает утечка памяти
Моделирование утечки памяти:
#include <random>
int n = 0;
cin >> n;
mt19937_64 random_gen{};
uint64_t sum = 0U;
for (int i = 0; i < n; ++i)
{
    auto x = new uint64_t;
    *x = random_gen();
    sum += *x;
    delete x; // если убрать строчку, то произойдёт утечка памяти
              // (забьётся всё ОЗУ, если подать достаточно большое n)
}
cout << sum;

delete не только освобождает память, но и вызывает деструктор класса

Для создания в куче N объектов типа T используется оператор new T[N]
Для их освобождения используется оператор delete[]
Если вместо delete[] вызвать delete, программа может работать некорректно

Стек - это область оперативной памяти
Прибавление числа X к указателю на тип T изменяет его адрес на X * sizeof(T)
При выполнении арифметики указателей не выполняется контроль доступа
Если p имеет тип T*, то записи *(p + 5) и p[5] эквивалентны

Пары методов begin и end для контейнера:
T *begin() { return data; }
T *end() { return _end; }
const T *begin() const { return data; }
const T *end() const { return _end; }

const T *ptr - Указатель на константу
T *const ptr - Константный указатель
const T *const ptr - Константный указатель на константу

vector
capacity - количество элементов, умещающихся в памяти вектора
при push_back может выделяться память
reserve позволяет зарезервировать достаточное количество памяти и сэкономить
на реаллокациях
shrink_to_fit позволяет сэкономить память, получив capacity == size

Указатели и ссылки на элементы вектора могут инвалидироваться при изменении
его размера
Дек не обладает такой проблемой
Защита от инвалидации - использовании дека или хранение индексов вместо
указателей

Вектор или Дек?
Вектор:
- быстрое обращение к элементу
- быстрое итерирование
Дек:
- быстрая серия push_back при неизвестном заранее размере
- быстрая вставка в начало
- неинвалидация ссылок

Инвалидация итераторов
Итераторы в целом мощнее указателей
Итераторы вектора ожидаемо инвалидируются
Дек может сохранять указатели валидными, но с итераторами всё гораздо
сложнее
Дек может уберечь ссылки от инвалидации, но не может убереть итераторы

Список (list)
Достоинства:
- быстрое удаление из середины
- неинвалидация ссылок и итераторов при удалении
Недостатки:
- невозможность быстро обратиться к элементу по индексу
- выделение памяти под каждый элемент

Методы списка
Константные (O(1)):
- size, empty
- push_back, pop_back
- push_front, pop_front
- insert, erase от итераторов
Линейные: reverse, unique, remove, remove_if
Сортировка за O(NLogN): метод sort

Итоги
Список эффективен, если необходимо удалять из середины (или вставлять
в середину) быстро и не инвалидируя итераторы
Итераторы списка имеют категорию bidirectional
На практике списки нужны редко
Ещё реже нужен контейнер forward_list - список, позволяющий итерироваться
только вперёд

string_view позволяет сослаться на диапазон символов, не владея им
Позиции более уместны при работе со string и string_view, чем итераторы
Методы remove_prefix и remove_suffix позволяют удобно итерироваться по string_view

Итерирование с remove_prefix:
while (true)
{
    size_t space = str.find(' ');
    result.push_back(str.substr(0, space));
    if (space == str.npos)
    {
        break;
    }
    else
    {
        str.remove_prefix(space + 1);
    }
}

Когда может возникнуть перемещение
Инициализация и присваивание
Помещение в контейнер:
- vector<T>::push_back,
  vector<T>::insert
- deque<T>::push_back,
  deque<T>::push_front, deque<T>::insert
- set<T>::insert, map<K, V>::operator[]
- и другие методы, копирующие аргументы

Функция move позволяет инициировать перемещение там, где случилось бы
копирование
Сама функция move не перемещает, она лишь заставляет компилятор переместить
Как правило, после перемещения объект остаётся пустым

Если у объекта много данных на стеке, перемещение не поможет или поможет плохо
Вызов move для константного объекта бесполезен. Следите за константностью
перемещаемого объекта

Копирование и присваивание для собственнных типов:
- при необходимости компилятор сам генерирует конструктор копирования и присваивания,
которые просто копируют все поля
- нужно писать собственные конструкторы копирования и присваивания для типов, которые управляют памятью, например, SimpleVector

class Logger
{
public:
    Logger() { cout << "Default ctor\n"; }
    Logger(const Logger &) { cout << "Copy ctor\n"; }
    void operator=(const Logger &) { cout << "Copy assignment ctor\n"; }
    Logger(Logger &&) { cout << "Move ctor\n"; }
    void operator=(Logger &&) { cout << "Move assignment ctor\n"; }
};

template <typename T>
SimpleVector<T>::SimpleVector(const SimpleVector<T> &other)
    : data(new T[other.capacity]),
      size(other.size),
      capacity(other.capacity)
{
    copy(other.cbegin(), other.cend(), begin());
}

Конструктор перемещения:
vector<int> source = /* ... */;
vector<int> target = move(source);
vector<int> target2(move(target));

vector<vector<int>> vectors;
vectors.push_back(vector<int>(5));
Во всех случаях вызывается конструктор перемещения
(move constructor)

Оператор перемещающего присваивания:
vector<int> source = /* ... */;
vector<int> target = /* ... */;
target = move(source);
target = vector<int>(5);
В обоих случаях вызывается оператор перемещающего присваивания
(move assignment operator)

rvalue-ссылки
Перегрузка по rvalue-ссылке - способ отличить временный объект от постоянного
target = source;         // вызывается operator=(const vector<int> &)
target = vector<int>(5); // вызывается operator=(vector<int> &&)
target = move(source);   // вызывается operator=(vector<int> &&)

Если метод должен принять объект и положить его в контейнер,
принимайте параметр по значению:
void Objects::Add(Object object)
{
    data.insert(move(object));
}
Временный объект перместится в object, а оттуда - в контейнер (два перемещения)
Постоянный объект скопируется в object, а оттуда переместится в контейнер

Перемещение в push_back
vector<T>::push_back(const T&)
вызывает T::T(const T &), копируя свой аргумент
vector<T>::push_back(T &&)
вызывает T::T(T&&), перемещая свой аргумент

Перемещение в методах контейнеров
Если одна из версий метода принимает rvalue-ссылку,
метод умеет перемещать свой аргумент

Если обернуть итератор в make_move_iterator, вместо копирования из него
будет перемещение
Примеры: merge, set_intersection и пр.
Вместо copy от move-итераторов можно использовать алгоритм move
Можно оптимизировать сортировку слияниями

Существуют типы, которые нельзя копировать, например, потоки ввода и вывода
Разрешено только перемещение
Попытка их скопировать порождает ошибку "use of deleted function..."

В некоторых случаях компилятор опускает перемещение и копирование:
- возврат из функции временного объекта (copy elision)
- инициализация временным объектом (copy elision)
- возврат из функции локальной переменной (NRVO - named return value optimization)