
## Потоковые манипуляторы

#include <iomanip>
setw - задать ширину поля ввода
setprecision - точность вывода вещественных чисел
setfill - заполнитель для setw
left - выравнивание данных по левому краю
fixed - выведение чисел в фиксированном формате

## Ввод и вывод пользовательских типов
// оператор вывода в поток
ostream& operator<<(ostream &s, Obj &o)
// оператор ввода из потока
istream& operator>>(istream &s, Obj &o)

## Удобное использование пользовательских типов
??? operator ???(???)
bool operator <(const &Tobj lhs, const &Tobj rhs)
Tobj operator +(const &Tobj lhs, const &Tobj rhs)

## Удобный способ сообщить о проблеме: exception, runtime_error, ...
try
{
    // опасный код
}
catch (const exception &e)
{
    // обработка ошибки
    // e.what() возвращает текст ошибки
}

## Кортежи:
- Упрощают реализацию operator<
- Позволяют вернуть несколько значений из функции и сохранить их
Пары - частный случай кортежей, но чуть приятнее

## structure bindings
tuple<bool, string> FindCountry()
{
    return {false, "Not exist"};
}

auto [success, message] = FindCountry();

## Вставка в произвольное место вектора
v.insert(it, value) вставляет value перед итератором it:
v.insert(v.end(), value) вставит value перед end

v.insert(it, range_begin, range_end)
вставляет диапазон [range_begin, range_end] в позицию it
v.insert(it, count, value)
count раз вставляет элемент value в позицию it
v.insert(it, {1, 2, 3})
вставляет 1, 2, 3 в позицию it

## Обратные итераторы
Упрощают итерирование по контейнеру в обратную сторону
sort(rbegin(v), rend(v)) - сортировка вектора по убыванию

## Справочник по C++ - https://ru.cppreference.com/w/
## Алгоритмы C++ - https://ru.cppreference.com/w/cpp/algorithm

## Категории итераторов
Input: итераторы любых контейнеров
Forward, Bidir: итераторы любых контейнеров (кроме set и map, если нужно менять содержимое)
Random: итераторы векторов и строк
Output: итераторы векторов и строк, inserter, back_inserter
Полный список требований к input-итераторам: https://en.cppreference.com/w/cpp/named_req/InputIterator
Полный список требований к output-итераторам: https://en.cppreference.com/w/cpp/named_req/OutputIterator
Полный список требований к forward-итераторам: https://en.cppreference.com/w/cpp/named_req/ForwardIterator
Полный список требований к bidirectional-итераторам: https://en.cppreference.com/w/cpp/named_req/BidirectionalIterator
Полный список требований к итераторам произвольного доступа: https://en.cppreference.com/w/cpp/named_req/RandomAccessIterator
Полный список требований к contiguous-итераторам: https://en.cppreference.com/w/cpp/named_req/ContiguousIterator
next замещает it + 1 или it + n;
prev замещает it - 1 или it - n;
advance замещает it += n;
distance замещает it2 - it1.
vector<bool> устроен так, что каждый элемент занимает в нём не один байт (как одна переменная типа bool), а один бит

## Дек - очередь
#include <deque>
d.push_back(x), d.pop_back()
d.push_front(x) - добавление в начало
d.pop_front() - удаление из начала
d[i] - обращение по индексу
Дек умеет больше, чем вектор, поэтому менее эффективен.
Если нужно только записывать и удалять из конца, то использовать вектор

## Очередь
#include <queue>
Умеет совсем немного:
q.push(q), q.pop() - добавляет в конец и удаляет из начала
q.front(), q.back()
q.size(), q.empty()
по данному контейнеру нельзя проитерироваться

## Стэк
#include <stack>
Позволяет лишь добавлять в конец и удалять из конца
Как вектор, но умеет меньше:
st.push(x), st.pop()
st.top()
st.size(), st.empty()

Если нужен вектор с добавлением в начало или удалением из начала, используйте deque
Нужна лишь очередь - используйте queue
Нужен стек, а не целый вектор - используйте stack

## Поиск в отсортированном векторе
Проверка на существование:
binary_search(begin(v), end(v), x)
Первый элемент, больший или равный данному:
lower_bound(begin(v), end(v), x)
Первый элемент, больший данного:
upper_bound(begin(v), end(v), x)
Диапазон элементов, равных данному:
equal_range(begin(v), end(v), x) == make_pair(lower_bound(...), uppder_bound(...))

## equal_range
Если элемент есть, equal_range = [lower_bound, upper_bound] - диапазон всех вхождений
Если элемента нет, lower_bound == upper_bound - позиция, куда можно вставить элемент без нарушения порядка сортировки
Найти количество вхождений - upper_bound - lower_bound
Как перебрать все вхождения - проитерироваться от lower_bound до upper_bound

Вместо алгоритмов лучше использовать именно методы, если они есть у контейнера

remove_if – оставляет в начале вектора элементы, не удовлетворяющие условию;
unique – оставляет в начале вектора по одному элементу из группы подряд идущих
повторений;
min_element, max_element, minmax_element – min, max элементы;
all_off – проверка условия для всех элементов.

sort(rbegin(langs), rend(langs)); – простой способ сортировки вектора по убыванию

Выведем позиции всех пробелов в строке:
for (auto it = find(begin(s), end(s), ' ');
it != end(s);
it = find(next(it), end(s), ' ')) { // переходим в цикле к следующему пробелу
cout << it − begin(s) << " "; // next(it) эквивалентен it + 1
}

## Макросы
Оператор # вставляет в код строковое представление параметра макроса
Макросы __FILE__ и __LINE__ автоматизируеют формирование сообщения для ассерта
Если ваш макрос не используется __FILE__, __LINE__ или #, подумайте, можно ли обойтись без него
Если всё же пишите макрос: старайтесь использовать каждый аргумент только один раз,
старайтесь максимально изолировать аргументы с помощью скобок

## Порождающие функции
Преимущества:
- сокращают код, перекладывая на компилятор вывод параметров шаблона
Недостатки:
- их нужно писать самому
- auto full = MakeRange(t.begin(), t.end()) - неочевиден тип переменной full

## Вывод типов в шаблонах классов в C++17
Если в классе есть конструктор, позволяющий определить тип шаблона, компилятор
выводит его сам:
template <class T>
struct Widjet
{
    Widjet(T value);
};
Widjet w_int(5);    // Widjet<int>
Widjet w_char('a'); // Widjet<char>

Явное указание типа шаблона может быть громоздким
Есть два способа возложить вывод типа на компилятор:
1. Порождающая функция
2. Конструктор, принимающий параметры всех шаблонных типов

По умолчанию при инстанцировании стоит явно указывать шаблонный тип
Если это неудобно, попробовать второй способ - в нём явно указано имя шаблона
IteratorRange second_half(t.begin(), t.end() / 2, t.end());
pair p(true, t.begin());
Если он не подходит, делаем порождающую функцию:
auto p = make_pair(5, bool);

В качестве возвращаемого типа функции можно использовать ключевое слово auto
Оно говорит компилятору: "Возьми тип из команды return"
По умолчанию следует явно указывать тип результата функции
Использовать auto в качестве типа результата функции стоит только если:
- типа результата громоздкий
- тело функции очень короткое
В противном случае может пострадать понятность кода

Код не бывает просто быстрым или медленным
Он бывает достаточно быстрым для своей задачи

Как правило код надо стараться делать правильным, простым, а только потом быстрым
Это не значит, что о производительности вообще не надо думать

Избегайте преждевременной оптимизации

Принцип Парето
80% времени работы программы тратится на исполнение 20% кода
Эти 20% и надо оптимизировать, но сначали их надо найти

Недостатки преждевременной оптимизации:
- необоснованное усложнение кода
- усложнение поддержки кода
- замедление разработки

Дональд Кнут:
Преждевременная оптимизация это корень всех зол

Уильям Вульф:
Во имя эффективности, которая при этом не всегда достигается, совершается гораздо
больше грехов, чем по любой другой причине, включая полную глупость

Прежде, чем ускорять код, замерьте сколько он работает
Если это недостаточно быстро, начинайте искать узкие места
Интуиция не работает - измеряйте!

ofstream не сразу выводит в файл, а буферизирует выведенные в него данные
cout и cerr ведут себя точно так же
Манипулятор endl не только выводит перевод строки, но и сбрасывает буфер потока в файл

Когда использовать endl:
В ситуациях, Когда
- скорость не так важна
- важно сразу видеть результата
Примеры:
- LogDuration
- TestRunner::RunTest

Когда использовать \n:
- в программах stdin -> stdout

Связанность стандартных потоков
По умолчанию потоки cout и cerr связаными с потоком cin
Перед каждой операцией ввода их буферы сбрасываются
Это может замедлять программы типа stdint -> stdout
наряду с заменой \n на endl добавляйте cin.tie(nullptr) в начало своих программ
команда ios_base::sync_with_stdio(false) может ещё больше ускорить программу,
но вызывать её нужно до всех команд ввода/вывода, иначе программа может работать непредсказуемо

Для программ тип stdin -> stdout рекомендуется не использовать endl
А также в самое начало добавлять код
ios_base::sync_with_stdio(false)
cin.tie(nullptr)

Сложность изученных алгоритмов:
Константная (1):
- арифметические операции
- обращение к элементу вектора
Логарифмитическая (LogN):
- двоичный поиск (lower_bound и пр.)
- поиск в set или map
Линейная (N):
- цикл for (с лёгкими итерациями)
- алгоритмы find_if, min_element и пр.
NlogN:
- алгоритм set (с лёгкими итерациями)
Часто используют O-символику:
O(N), O(NlogN) и т.д.

for (int &x :numbers_to_find)
{
    lower_bound(begin(v), end(v), x);
    x *= 2;
}
Сколько работает такой код?
numbers_to_find.size() * (log(v.size()) + 1)
Простая математика: сложение и умножение

Сравнение алгоритмов:
1 < logN < N < NlogN < N^2
При сложении большее поглощает меньшее:
O(N) + O(logN) = O(N)
O(5N) и O(8N) надо сравнивать измерениями
Геометрические и графические задачи могут иметь очень большую константу в сложности

Как оценить время работы?
Рассматриваем худший случай
Вычисляем количество операций при максимальном N
Умножаем на константу ~ 10-50
Очень грубо оценили количество операций
За секунду можно успеть 10^9
Измеряйте конкретный алгоритм на больших данных!

## Модель памяти
В модели памяти C++ есть два источника памяти:
- Стек
- Куча
В стеке размещаются локальные переменные функции
В куче - объекты, которые должны жить дольше, чем создавшая их функция

Для создания объектов в куче используется оператор new (возвращает указатель)
Инициализация объектов, созданных в куче, выполняется так же, как для объектов на стеке
int *pInt = new int; - значение не определено
string *pString = new string; - значение не определено

int *pInt = new int(42); - значение определено
string *pString = new string("Hi"); - значение определено

Оператор delete позволяет освободить память, выделенную через new
Если этого не делать, возникает утечка памяти
Моделирование утечки памяти:
#include <random>
int n = 0;
cin >> n;
mt19937_64 random_gen{};
uint64_t sum = 0U;
for (int i = 0; i < n; ++i)
{
    auto x = new uint64_t;
    *x = random_gen();
    sum += *x;
    delete x; // если убрать строчку, то произойдёт утечка памяти
              // (забьётся всё ОЗУ, если подать достаточно большое n)
}
cout << sum;

delete не только освобождает память, но и вызывает деструктор класса

Для создания в куче N объектов типа T используется оператор new T[N]
Для их освобождения используется оператор delete[]
Если вместо delete[] вызвать delete, программа может работать некорректно

Стек - это область оперативной памяти
Прибавление числа X к указателю на тип T изменяет его адрес на X * sizeof(T)
При выполнении арифметики указателей не выполняется контроль доступа
Если p имеет тип T*, то записи *(p + 5) и p[5] эквивалентны

Пары методов begin и end для контейнера:
T *begin() { return data; }
T *end() { return _end; }
const T *begin() const { return data; }
const T *end() const { return _end; }

const T *ptr - Указатель на константу
T *const ptr - Константный указатель
const T *const ptr - Константный указатель на константу